#Computer assisted proof of a spike solution for the 2D Gray Scott reduced equation (i.e. ŒªŒ≥ = 1): Œª‚ÇÅŒîu - u + u¬≤ - Œª‚ÇÅv¬≥ = 0
# The following code computes the solution and rigorously proves the results given in section 6 of
# "Localized stationary patterns in the 2D Gray-Scott model: computer assisted proofs of existence"  M. Cadiot and D. Blanco

# First, the code computes the approximate solution using the initial guess described in section 3 of the aforementioned paper.
# From this we can check if the proof of the solution is verified or not. We essentially prove Theorem 6.1.

#####################################################################################################################################################################

# Choice of the parameters for the proof of spikes when 0 < Œ≥ < 2/9:
# Œª‚ÇÇ = 9
# Œª‚ÇÅ = 1/9

# Needed packages
using RadiiPolynomial, IntervalArithmetic, LinearAlgebra, FFTW

# Needed additional sequence structures for RadiiPolynomial (see Remark 2.3)
include("D4Fourier.jl")

#####################################################################################################################################################################


#################################### List of the needed functions : go directly to line 180 for the main code ################################################# 

# Converts a sequence to D‚ÇÑFourier
function Convert2D‚ÇÑ(a)
    N = order(a)[1]
    f = frequency(a)[1]
    anew = Sequence(D‚ÇÑFourier(N,f), zeros(dimension(D‚ÇÑFourier(N,f))))
    for k‚ÇÇ = 0:N
        for k‚ÇÅ = k‚ÇÇ:N
            anew[(k‚ÇÅ,k‚ÇÇ)] = a[(k‚ÇÅ,k‚ÇÇ)]
        end
    end
    return anew
end

# Equivalent of meshgrid function from Matlab
function _meshgrid(x,y)
    Nx = length(x)
    Ny = length(y)
    X = zeros(Ny,Nx)
    Y = zeros(Ny,Nx)
    for j = 1:Nx
        for i = 1:Ny
            X[i,j] = x[j]
            Y[i,j] = y[i]
        end
    end
    return X,Y
end

# Computes the result in Lemma 4.1
function œÜ(A,B,C,D)
    O‚ÇÅ = max(A,D) + max(B,C)
    O‚ÇÇ = sqrt(A^2 + D^2 + B^2 + C^2)
    return min(O‚ÇÅ,O‚ÇÇ)
end

# Computes the Fourier coefficients of 1_ùíü‚ÇÄ¬≤.
function _char_boundary_coeffs(N,f,d)
    char = Sequence(Fourier(N,f)‚äóFourier(N,f), Interval.(complex.(zeros((2N+1)^2))))
    for n‚ÇÇ = -N:N
        for n‚ÇÅ = -N:N
            char[(n‚ÇÅ,n‚ÇÇ)] = interval(1)/(interval(4)*d^2) * exp(1im*n‚ÇÅ*interval(œÄ)*(interval(1)/d * interval(1/2) - interval(1)))*exp(1im*n‚ÇÇ*interval(œÄ)*(interval(1)/d * interval(1/2) - interval(1))) * sinc(n‚ÇÅ/d*interval(1/2))*sinc(n‚ÇÇ/d*interval(1/2))
        end
    end
    rchar = Sequence(D‚ÇÑFourier(N,f), interval.(zeros(dimension(D‚ÇÑFourier(N,f)))))
    for n‚ÇÇ = 0:N
        for n‚ÇÅ = n‚ÇÇ:N
            rchar[(n‚ÇÅ,n‚ÇÇ)] = real(char[(n‚ÇÅ,n‚ÇÇ)] + char[(n‚ÇÇ,-n‚ÇÅ)] + char[(-n‚ÇÅ,-n‚ÇÇ)] + char[(-n‚ÇÇ,n‚ÇÅ)])
        end
    end
    return rchar
end

# Computes the sequence a(d,‚ãÖ) for a in D‚ÇÑFourier.
function _sequence_on_boundary(a)
    N = order(a)[1]
    f = frequency(a)[1]
    anew = Sequence(CosFourier(N,f), interval.(zeros(N+1)))
    for n‚ÇÅ = 0:N
        for n‚ÇÇ = -N:N
            anew[n‚ÇÅ] += a[(max(n‚ÇÅ,abs(n‚ÇÇ)),min(n‚ÇÅ,abs(n‚ÇÇ)))]*(-1)^n‚ÇÇ
        end
    end
    return anew
end

# Computes the Fourier coefficients of 1_ùíü‚ÇÄ
function _char_1D_boundary_coeffs(N,f,d)
    char = Sequence(Fourier(N,f), Interval.(complex.(zeros((2N+1)))))
    for n = -N:N
        char[n] = interval(1)/(interval(2)*d) * exp(1im*n*interval(œÄ)*(interval(1)/d * interval(1/2) - interval(1))) * sinc(n/d*interval(1/2))
    end
    rchar = Sequence(CosFourier(N,f), interval.(zeros(N+1)))
    for n = 0:N
        rchar[n] = real(char[n] + char[-n])
    end
    return rchar
end

# Computes the function needed to take the convolution with ‚àÇ‚Çì‚ÇÅV‚ÇÅ·¥∫
# We denote by (VÃÉ‚±º)‚Çò = |mÃÉ‚ÇÅ| (V‚±º·¥∫)‚Çò 
function _VÃÉ‚±º_coeffs(V‚±º·¥∫)
    N = order(V‚±º·¥∫)[1]
    f = frequency(V‚±º·¥∫)[1]
    VÃÉ‚±º = Sequence(CosFourier(N,f)‚äóCosFourier(N,f), interval.(zeros((N+1)^2)))
    for n‚ÇÅ = 0:N
        for n‚ÇÇ = 0:N
            VÃÉ‚±º[(n‚ÇÅ,n‚ÇÇ)] = abs(n‚ÇÅ)*f*V‚±º·¥∫[(max(n‚ÇÅ,n‚ÇÇ),min(n‚ÇÅ,n‚ÇÇ))]
        end
    end
    return VÃÉ‚±º
end

# Gray-Scott reduced equation
function F·µ£!(F·µ£,U,Œª‚ÇÅ)
    project!(F·µ£,Laplacian(2)*U*Œª‚ÇÅ + U^2 - Œª‚ÇÅ*U^3 - U)
    return F·µ£
end

# Derivative of the Gray-Scott reduced equation
function DF·µ£!(DF·µ£,U,Œª‚ÇÅ)
    DF·µ£ .= 0
    Œî = project(Laplacian(2),space(U),space(U),Float64)
    ùïå = project(Multiplication(U),space(U),space(U),Float64)
    ùïå¬≤ = project(Multiplication(U^2),space(U),space(U),Float64)
    DF·µ£ = Œî*Œª‚ÇÅ + 2ùïå - 3Œª‚ÇÅ*ùïå¬≤ - I
    return DF·µ£
end

# Newton function
function _newton_gs(UÃÑ‚ÇÄ,jmax,Œª‚ÇÅ)
    GS = similar(UÃÑ‚ÇÄ)
    s = space(UÃÑ‚ÇÄ)
    r = length(UÃÑ‚ÇÄ)
    DGS = LinearOperator(s,s,similar(coefficients(UÃÑ‚ÇÄ),r,r))
    j = 0
    œµ = 1
    nv = 1
    while (œµ > 1e-14) & (j < jmax)
        GS = F·µ£!(GS,UÃÑ‚ÇÄ,Œª‚ÇÅ)
        DGS = DF·µ£!(DGS,UÃÑ‚ÇÄ,Œª‚ÇÅ)
        UÃÑ‚ÇÄ = UÃÑ‚ÇÄ - DGS\GS
        @show œµ = norm(GS,Inf)
        nu = norm(UÃÑ‚ÇÄ)
        if nu < 1e-5
            @show nu
            display("Newton may have converged to the 0 solution")
            return nv,j
            break
        end
        j += 1
    end
    return UÃÑ‚ÇÄ,œµ
end

# Œ±‚Çô for the trace operator (see Section 3.2).
function Œ±‚Çô(n)
    if n[1] == n[2] == 0
        return 1
    elseif n[1] == n[2] != 0
        return 4
    elseif (n[1] != 0) & (n[2] == 0)
        return 2
    else
        return 4
    end
end

# Computes the trace for a D‚ÇÑFourier sequence.
function _trace_D‚ÇÑ(N)
    M = dimension(D‚ÇÑFourier(N,1.0))
    S = zeros(N+1,M)
    for n‚ÇÇ = 0:N
        for n‚ÇÅ = 0:N
            m = (max(n‚ÇÅ,n‚ÇÇ),min(n‚ÇÅ,n‚ÇÇ))
            Œ± = Œ±‚Çô(m)
            S[n‚ÇÅ+1,m[1] + m[2]*N - div(((m[2]-2)^2 + 3*(m[2]-2)),2)] = Œ±*(-1)^n‚ÇÇ
        end
    end
    return S
end

# Allows us to switch between D‚ÇÑ and exponential Fourier series
function _exp2D‚ÇÑ!(D::Vector{Float64},s::D‚ÇÑFourier)
    k = 1
    ord = order(s)[1]
    for k‚ÇÇ = 0:ord
        for k‚ÇÅ = k‚ÇÇ:ord
            if k‚ÇÅ == k‚ÇÇ == 0
                D[k] = 1
                k += 1
            elseif k‚ÇÅ == k‚ÇÇ != 0
                D[k] = sqrt(4)
                k += 1
            elseif (k‚ÇÅ != 0) & (k‚ÇÇ == 0)
                D[k] = sqrt(4)
                k += 1
            else
                D[k] = sqrt(8)
                k +=1 
            end
        end
    end
    return D
end

# Allows us to switch between D‚ÇÇ and exponential Fourier series
function exp2cos(N)

    d = 2*((ones((N+1)^2)))

    d[1] = 1;
    for n2=1:N
        d[n2+1] = sqrt(2);
    end

    for n1 = 1:N
        d[n1*(N+1)+1] = sqrt(2);
    end

    return d
end

# Computes convolution of D‚ÇÑFourier sequences up to order N
function _conv_small(u,v,N)
    #Computes u*v only up to order N
    order_u = order(space(u))[1]
    order_v = order(space(v))[1]
    C = Sequence(D‚ÇÑFourier(N,frequency(u)[1]), interval.(zeros(dimension(D‚ÇÑFourier(N,frequency(u)[1])))))
    for i‚ÇÇ ‚àà 0:N
        for i‚ÇÅ ‚àà i‚ÇÇ:N
            C·µ¢ = interval(zero(Float64))
            @inbounds @simd for j‚ÇÅ ‚àà max(i‚ÇÅ-order_u, -order_v):min(i‚ÇÅ+order_u, order_v)
                @inbounds for j‚ÇÇ ‚àà max(i‚ÇÇ-order_u, -order_v):min(i‚ÇÇ+order_u, order_v)
                    tu = (max(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)),min(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)))
                    tv = (max(abs(j‚ÇÅ),abs(j‚ÇÇ)),min(abs(j‚ÇÅ),abs(j‚ÇÇ)))
                    C·µ¢ += u[tu] * v[tv]
                end
            end
            C[(i‚ÇÅ,i‚ÇÇ)] = C·µ¢
        end
    end
    return C
end

# Performs convolution up to order N of a D‚ÇÑ and D‚ÇÇ Fourier series
function __conv_small(u,v,N)
    #Computes u*v up to order N
    #u is a sequence in D‚ÇÑFourier
    #v is a sequence in CosFourier ‚äó CosFourier (D‚ÇÇ symmetric)
    order_u = order(space(u))[1]
    order_v = order(space(v))[1]
    C = Sequence(CosFourier(N,frequency(u)[1])‚äóCosFourier(N,frequency(u)[1]), interval.(zeros((N+1)^2)))
    for i‚ÇÅ ‚àà 0:N
        for i‚ÇÇ ‚àà 0:N
            C·µ¢ = interval(zero(Float64))
            @inbounds @simd for j‚ÇÅ ‚àà max(i‚ÇÅ-order_u, -order_v):min(i‚ÇÅ+order_u, order_v)
                @inbounds for j‚ÇÇ ‚àà max(i‚ÇÇ-order_u, -order_v):min(i‚ÇÇ+order_u, order_v)
                    tu = (max(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)),min(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)))
                    tv = (abs(j‚ÇÅ),abs(j‚ÇÇ))
                    C·µ¢ += u[tu] * v[tv]
                end
            end
            C[(i‚ÇÅ,i‚ÇÇ)] = C·µ¢
        end
    end
    return C
end

# Checks the conditions of the Radii-Polynomial Theorem (see Section 4).
function CAP(ùí¥‚ÇÄ,ùíµ‚ÇÅ,ùíµ‚ÇÇ,s‚ÇÄ)
    if ùíµ‚ÇÅ + ùíµ‚ÇÇ*s‚ÇÄ < 1
        if interval(1/2)*ùíµ‚ÇÇ*s‚ÇÄ^2 - (interval(1)-ùíµ‚ÇÅ)*s‚ÇÄ + ùí¥‚ÇÄ < 0
          display("The proof was successful for s‚ÇÄ = ")
          display(sup(s‚ÇÄ))  
        else
          display("The condition 2ùí¥‚ÇÄ*ùíµ‚ÇÇ < (1-ùíµ‚ÇÅ)¬≤ is not satisfied")
        end
    else
        if ùíµ‚ÇÅ > 1
            display("ùíµ‚ÇÅ is too big")
        else
          display("failure: linear term is positive")
        end
      end
end

################### PROOF OF SPIKE SOLUTION : MAIN CODE #################################################################################################################################################
N = 20              # number of Fourier modes : 0 ‚â§ n‚ÇÇ ‚â§ n‚ÇÅ ‚â§ N for D‚ÇÑ series
d = 4 ; di = interval(d)   # size of the domain = half period of the functions
Œª‚ÇÅ = 1/9 ; Œª‚ÇÅi = interval(Œª‚ÇÅ)    # value of the parameter. Œª‚ÇÅ = 1/Œª‚ÇÇ
Q = sqrt(1-9*Œª‚ÇÅ/2)     # Quantity Q defined in "Exact Homoclinic and Heteroclinic Solutions of the Gray-Scott Model for Autocatalysis" J. K. Hale, L. A. Peletier and W. C. Troy
fourier = D‚ÇÑFourier(N,œÄ/di)   # definition of the sequence space : D‚ÇÑ series of frequency œÄ/d
x = 2*d/(2*N+1)*(-N:N)
y = x
X,Y = _meshgrid(x,y)
UÃÑ‚ÇÄ = 3 ./(1 .+Q*cosh.(sqrt.((X.^2+Y.^2)/Œª‚ÇÅ)))
s‚ÇÄ = interval(0.0005) # Value of s‚ÇÄ for ùíµ‚ÇÇ

# Constructing approximate solution via Newton's method
UÃÇ‚ÇÄ = fftshift(FFTW.fft(ifftshift(UÃÑ‚ÇÄ))/(2N+1)^2)
UÃÑ‚ÇÄ_full = Sequence(Fourier(N,œÄ/d)‚äóFourier(N,œÄ/d), real(vec(UÃÇ‚ÇÄ)))
UÃÑ‚ÇÄ = Convert2D‚ÇÑ(UÃÑ‚ÇÄ_full)
U‚ÇÄ,œµ = _newton_gs(UÃÑ‚ÇÄ,30,Œª‚ÇÅ) 
U‚ÇÄ_interval = Sequence(fourier, coefficients(interval.(U‚ÇÄ)))

#################################################   Projection on X¬≤‚ÇÄ(‚Ñù¬≤)   ##################################################################################
# Projection of U‚ÇÄ in X¬≤‚ÇÄ(‚Ñù¬≤) : U‚ÇÄ needs to represent a function in H¬≤‚ÇÄ(Œ©‚ÇÄ)
# We define ùíØ as the trace operator (ùíØU = 0 means that U ‚àà X¬≤‚ÇÄ(‚Ñù¬≤)) and ùíØ·µÄ as its adjoint
ùíØ = interval.(_trace_D‚ÇÑ(N)) ; ùíØ·µÄ = ùíØ'

# We build the operator L and its inverse L‚Åª¬π. 
Œî = project(Laplacian(2), fourier, fourier,Interval{Float64})
L‚ÇÅ‚ÇÅ = -I + Œî*Œª‚ÇÅi
L‚ÇÅ‚ÇÅ‚Åª¬π = interval.(ones(dimension(fourier)))./diag(coefficients(L‚ÇÅ‚ÇÅ))
#Finally we can build the projection of U‚ÇÄ on X¬≤‚ÇÄ that we denote U‚ÇÄ again Doing U‚ÇÄ = U‚ÇÄ - L‚ÇÅ‚ÇÅ‚Åª¬πùíØ·µÄ(ùíØL‚ÇÅ‚ÇÅ‚Åª¬πùíØ·µÄ)‚Åª¬πùíØ
U‚ÇÄ_interval = U‚ÇÄ_interval - Sequence(fourier, vec(L‚ÇÅ‚ÇÅ‚Åª¬π.*Matrix(ùíØ·µÄ)*inv(Matrix(ùíØ*(L‚ÇÅ‚ÇÅ‚Åª¬π.*ùíØ·µÄ)))*Matrix(ùíØ)*U‚ÇÄ_interval[:]))

# # We define an operator P that help us to switch between the D‚ÇÑ and exponential series
# # (as the theoretical analysis is done in exponential series)
# # For a linear operator K between D‚ÇÑ fourier series, P*K*inv(P) gives the equivalent operator
# # on exponential series for the D‚ÇÑ modes (the other modes can be found by computing the orbits of the stored modes)
# # In particular, if K is diagonal, then P*K*inv(P) = K
P = interval.(vec(_exp2D‚ÇÑ!(zeros(dimension(fourier)),fourier)))
P‚Åª¬π = interval.(ones(dimension(fourier))./P)

# Computation of B and its norm
V‚ÇÄ_interval = interval(2)*U‚ÇÄ_interval - interval(3)*Œª‚ÇÅi*U‚ÇÄ_interval^2
DG·µ£ = project(Multiplication(V‚ÇÄ_interval),fourier,fourier,Interval{Float64})
B·µ£ = interval.(inv((I + mid.(DG·µ£).*mid.(L‚ÇÅ‚ÇÅ‚Åª¬π)')))
B·µ£_adjoint = LinearOperator(fourier,fourier, coefficients(B·µ£)')
norm_B·µ£ = sqrt(opnorm(LinearOperator(coefficients(P.*(B·µ£*B·µ£_adjoint).*P‚Åª¬π')),2))

# ################ ùí¥‚ÇÄ BOUND ######################################################
# Computation of the ùí¥‚ÇÄ bound for the reduced equation, defined in Lemma 5.3.
Œ©‚ÇÄ = (2*di)^2
tail_G·µ£ = U‚ÇÄ_interval^2 - Œª‚ÇÅi*U‚ÇÄ_interval^3
G·µ£ = project(tail_G·µ£,fourier)
ùí¥‚ÇÄ = sqrt(Œ©‚ÇÄ)*sqrt(norm(B·µ£*(L‚ÇÅ‚ÇÅ*U‚ÇÄ_interval+G·µ£),2)^2 + norm((tail_G·µ£-G·µ£),2)^2)
@show ùí¥‚ÇÄ

################################ ùíµ‚ÇÇ BOUND ######################################################
# Computation of the ùíµ‚ÇÇ bound for the reduced equation, defined in Lemma 5.4.
Œ∫‚ÇÇ = interval(1)/(interval(2)*sqrt(Œª‚ÇÅi*interval(œÄ)))
ùïå‚ÇÄ¬≤ = project(Multiplication(U‚ÇÄ_interval*U‚ÇÄ_interval),fourier,fourier,Interval{Float64})
ùíµ‚ÇÇ = interval(6)*Œª‚ÇÅi*Œ∫‚ÇÇ*sqrt(opnorm(LinearOperator(coefficients(P.*(B·µ£_adjoint*ùïå‚ÇÄ¬≤*B·µ£).*P‚Åª¬π')),2)+norm(U‚ÇÄ_interval,1)^2) + norm_B·µ£*(interval(2)*Œ∫‚ÇÇ + interval(3)*Œª‚ÇÅi*Œ∫‚ÇÇ^2*s‚ÇÄ)
@show ùíµ‚ÇÇ

################################ ùíµ·µ§ BOUND ######################################################
# Computation of the ùíµ·µ§ bound for the reduced equation, defined in Lemma 5.7.
a‚ÇÅ = sqrt(1/Œª‚ÇÅi)

################################ ùíµ·µ§‚ÇÅ BOUND ######################################################
C‚ÇÄf‚ÇÅ‚ÇÅ = max(a‚ÇÅ^2*interval(interval(2)*exp(interval(5/4)))*(interval(2)/a‚ÇÅ)^(interval(1/4)),a‚ÇÅ^2*sqrt(interval(œÄ)/(interval(2)*sqrt(a‚ÇÅ))))

# Computing the fourier series of E‚ÇÅ
E‚ÇÅ = Sequence(D‚ÇÑFourier(4N,œÄ/di), interval.(zeros(dimension(D‚ÇÑFourier(4N,œÄ/di)))))
for n‚ÇÇ = 0:4N
    for n‚ÇÅ = n‚ÇÇ:4N
        E‚ÇÅ[(n‚ÇÅ,n‚ÇÇ)] = real(interval(1)/(interval(8)*di) * ((interval(-1))^n‚ÇÅ*sinc(n‚ÇÇ)*(interval(1)/(interval(2)*a‚ÇÅ-im*n‚ÇÅ*interval(œÄ)/di) + interval(1)/(interval(2)*a‚ÇÅ + im*n‚ÇÅ*interval(œÄ)/di)) + (interval(-1))^n‚ÇÇ*sinc(n‚ÇÅ)*(interval(1)/(interval(2)*a‚ÇÅ-im*n‚ÇÇ*interval(œÄ)/di) + interval(1)/(interval(2)*a‚ÇÅ + im*n‚ÇÇ*interval(œÄ)/di))))
    end
end

# Computes a larger operator to convert from D‚ÇÑ to exponential since inner products will be of size 2N.
P2 = interval.(vec(_exp2D‚ÇÑ!(zeros(dimension(D‚ÇÑFourier(2N,œÄ/di))),D‚ÇÑFourier(2N,œÄ/di))))

#Inner Products
E‚ÇÅV‚ÇÄ = _conv_small(E‚ÇÅ,V‚ÇÄ_interval,2N)
_inner_prod_E‚ÇÅV‚ÇÄ = abs(coefficients(P2.*V‚ÇÄ_interval)'*coefficients(P2.*E‚ÇÅV‚ÇÄ))

ùíµ·µ§‚ÇÅ = sqrt(interval(2))*C‚ÇÄf‚ÇÅ‚ÇÅ*(interval(1)-exp(-interval(4)*a‚ÇÅ*di)) * (interval(2œÄ))^(interval(1/4))/a‚ÇÅ^(3/4) * sqrt(Œ©‚ÇÄ) * sqrt(_inner_prod_E‚ÇÅV‚ÇÄ)

################################ ùíµ·µ§‚ÇÇ BOUND ######################################################
# We begin by computing all the necessary constants.
# We start with C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ and C‚ÇÅ‚ÇÇf‚ÇÅ‚ÇÅ defined in Lemma 4.10.

C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ = a‚ÇÅ^3*sqrt(interval(œÄ/2))*interval(1)/sqrt(a‚ÇÅ + interval(1))*(interval(1) + interval(1)/a‚ÇÅ)
C‚ÇÅ‚ÇÇf‚ÇÅ‚ÇÅ = a‚ÇÅ^2*sqrt(interval(œÄ/2))*(sqrt(interval(2))*a‚ÇÅ + interval(1))

# Then, we define the constants C‚ÇÅ,ùíû‚ÇÅ‚ÇÅ, and ùíû‚ÇÇ‚ÇÅ defined in Lemma 4.10.
C‚ÇÅ = sqrt(di^2/(interval(16)*a‚ÇÅ^2*interval(œÄ)^5) + interval(1)/a‚ÇÅ^4 + di/a‚ÇÅ^3)
ùíû‚ÇÅ‚ÇÅ = interval(2)*sqrt(Œ©‚ÇÄ)*exp(-a‚ÇÅ*di)*(C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ*exp(-a‚ÇÅ) + C‚ÇÅ‚ÇÇf‚ÇÅ‚ÇÅ)/(a‚ÇÅ)
ùíû‚ÇÇ‚ÇÅ = interval(2)*sqrt(Œ©‚ÇÄ)*C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ*sqrt(log(interval(2))^2 + interval(2)*log(interval(2)) + interval(2))

# Now, we compute 1_ùíü‚ÇÄ¬≤ and 1_ùíü‚ÇÄ, the Fourier series representations of the
# characteristic functions on ùíü‚ÇÄ¬≤ and ùíü‚ÇÄ respectively. We do these computations
# using the functions _char_boundary_coeffs and _char_1D_boundary_coeffs.
print("Computing coefficients of characteristic function")
setprecision(80)
char = _char_boundary_coeffs(4N,frequency(U‚ÇÄ_interval)[1],di)
setprecision(80)
char1D = _char_1D_boundary_coeffs(4N,frequency(U‚ÇÄ_interval)[1],di)

P3 = interval.(exp2cos(2N))
P4 = interval.([1 ; sqrt(2)*ones(2N)])

VÃÉ‚ÇÄ_interval = _VÃÉ‚±º_coeffs(V‚ÇÄ_interval)
V‚ÇÄd_interval = _sequence_on_boundary(V‚ÇÄ_interval)

char‚àÇ‚Çì‚ÇÅV‚ÇÄ = __conv_small(char,VÃÉ‚ÇÄ_interval,2N)
_boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÄ = abs(coefficients(P3.*VÃÉ‚ÇÄ_interval)'*coefficients(P3.*char‚àÇ‚Çì‚ÇÅV‚ÇÄ))

charV‚ÇÄ = _conv_small(char,V‚ÇÄ_interval,2N)
_boundary_inner_prodV‚ÇÄ = abs(coefficients(P2.*charV‚ÇÄ)'*coefficients(P2.*V‚ÇÄ_interval))

char1DV‚ÇÄd = project(char1D*V‚ÇÄd_interval,space(V‚ÇÄd_interval))
_boundary_inner_prodV‚ÇÄd = abs(coefficients(P4.*char1DV‚ÇÄd)'*coefficients(P4.*V‚ÇÄd_interval))

CV‚ÇÄ = sqrt(interval(1/8) * sqrt(_boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÄ)*sqrt(_boundary_inner_prodV‚ÇÄ) + interval(1)/(interval(2)*di) * interval(1/4) * _boundary_inner_prodV‚ÇÄd)

ùíµ·µ§‚ÇÇ = interval(4)/sqrt(Œ©‚ÇÄ) * C‚ÇÅ * (ùíû‚ÇÅ‚ÇÅ * sqrt(_inner_prod_E‚ÇÅV‚ÇÄ) + ùíû‚ÇÇ‚ÇÅ*CV‚ÇÄ)
@show ùíµ·µ§‚ÇÇ

ùíµ·µ§ = sqrt(ùíµ·µ§‚ÇÅ^2 + ùíµ·µ§‚ÇÇ^2)
@show ùíµ·µ§

################################ Z‚ÇÅ BOUND ######################################################
# Computation of the Z‚ÇÅ bound for the reduced equation, defined in Lemma 5.6.
ùïç‚ÇÄ¬≤ = project(Multiplication(V‚ÇÄ_interval^2),fourier,fourier,Interval{Float64})
l‚ÇÅ‚ÇÅ‚Çô = ((interval((N+1)œÄ)/di)^2*Œª‚ÇÅi+interval(1))
M·µ£ = I + DG·µ£.*L‚ÇÅ‚ÇÅ‚Åª¬π'
M·µ£_adjoint = LinearOperator(fourier,fourier,coefficients(M·µ£)')
Z‚ÇÅ‚ÇÉ = sqrt(opnorm(LinearOperator(coefficients(P.*(L‚ÇÅ‚ÇÅ‚Åª¬π.*(ùïç‚ÇÄ¬≤ - DG·µ£^2).*L‚ÇÅ‚ÇÅ‚Åª¬π').*P‚Åª¬π')),2))
Z‚ÇÅ‚ÇÅ = sqrt(opnorm(LinearOperator(coefficients(P.*((I-B·µ£*M·µ£)*(I-M·µ£_adjoint*B·µ£_adjoint)).*P‚Åª¬π')),2))
Z‚ÇÅ‚ÇÇ = interval(1)/l‚ÇÅ‚ÇÅ‚Çô*sqrt(opnorm(LinearOperator(coefficients(P.*(B·µ£*(ùïç‚ÇÄ¬≤ - DG·µ£^2)*B·µ£_adjoint).*P‚Åª¬π')),2))
Z‚ÇÅ‚ÇÑ = interval(1)/l‚ÇÅ‚ÇÅ‚Çô*norm(V‚ÇÄ_interval,1)
Z‚ÇÅ = œÜ(Z‚ÇÅ‚ÇÅ,Z‚ÇÅ‚ÇÇ,Z‚ÇÅ‚ÇÉ,Z‚ÇÅ‚ÇÑ)

ùíµ‚ÇÅ = Z‚ÇÅ + norm_B·µ£*ùíµ·µ§
@show ùíµ‚ÇÅ

#Perform the Computer Assisted Proof
s_min = sup((interval(1) - ùíµ‚ÇÅ - sqrt((interval(1) - ùíµ‚ÇÅ)^2 - interval(2)*ùí¥‚ÇÄ*ùíµ‚ÇÇ))/ùíµ‚ÇÇ)
s_max = min(inf((interval(1) - ùíµ‚ÇÅ + sqrt((interval(1) - ùíµ‚ÇÅ)^2 - interval(2)*ùí¥‚ÇÄ*ùíµ‚ÇÇ))/ùíµ‚ÇÇ), inf((interval(1)-ùíµ‚ÇÅ)/ùíµ‚ÇÇ))
CAP(ùí¥‚ÇÄ,ùíµ‚ÇÅ,ùíµ‚ÇÇ,s‚ÇÄ)

################################ Proof of Periodic Solution #################################################
# The value of Œ∫ÃÇ‚ÇÇ defined in Theorem 5.8
Œ∫ÃÇ‚ÇÇ = sqrt(interval(1)/(interval(4œÄ)*Œª‚ÇÅi) + interval(1)/(interval(4)*di^2) + interval(1)/(interval(2)*di) * interval(œÄ)/sqrt(Œª‚ÇÅi))

# We can now perform the computer assisted proof for the branch of periodic solutions
ùíµ‚ÇÅ_hat = ùíµ‚ÇÅ+norm_B·µ£*ùíµ·µ§
ùíµ‚ÇÇ_hat = interval(6)*Œª‚ÇÅi*Œ∫ÃÇ‚ÇÇ*sqrt(opnorm(LinearOperator(coefficients(P.*(B·µ£_adjoint*ùïå‚ÇÄ¬≤*B·µ£).*P‚Åª¬π')),2)+norm(U‚ÇÄ_interval,1)^2) + norm_B·µ£*(interval(2)*Œ∫ÃÇ‚ÇÇ + interval(3)*Œª‚ÇÅi*Œ∫ÃÇ‚ÇÇ^2*s‚ÇÄ)
sÃÇ_min = sup((interval(1) - ùíµ‚ÇÅ_hat - sqrt((interval(1) - ùíµ‚ÇÅ_hat)^2 - interval(2)*ùí¥‚ÇÄ*ùíµ‚ÇÇ_hat))/ùíµ‚ÇÇ_hat)
sÃÇ_max = min(inf((interval(1) - ùíµ‚ÇÅ_hat + sqrt((interval(1) - ùíµ‚ÇÅ_hat)^2 - interval(2)*ùí¥‚ÇÄ*ùíµ‚ÇÇ_hat))/ùíµ‚ÇÇ_hat), inf((interval(1)-ùíµ‚ÇÅ_hat)/ùíµ‚ÇÇ_hat))
CAP(ùí¥‚ÇÄ,ùíµ‚ÇÅ_hat,ùíµ‚ÇÇ_hat,s‚ÇÄ)